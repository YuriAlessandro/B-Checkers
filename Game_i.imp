/* Game_i
* Author: PedroArthur
* Creation date: 12/06/2018
*/

IMPLEMENTATION Game_i
REFINES Game
    
SEES
    Table
    
CONCRETE_VARIABLES
    pieces_positions1_i, pieces_positions2_i
    
INVARIANT
    row1 = (0..11) --> (0..8) &
    column1 = (0..11) --> (0..8)  &
    row2 = (0..11) --> (0..8) &
    colunm2 = (0..11) --> (0..8) &
    dom(row1) = (0..11) &
    dom(column1) = (0..11)&
    dom(row2) = (0..11) &
    dom(column2) = (0..11) &
    !pp.(pp:(0..11) => pieces_positions1(pp) = (row1(pp),column1(pp))) &
    !pp.(pp:(0..11) => pieces_positions2(pp) = (row1(pp),column1(pp)))
    
    
INITIALISATION    
    current_player := P1;
    current_array := (0..3) * {0};
    current_piece := -1;
    VAR pc, rr, cc IN
        pc := 0;
        rr := 0;
        cc := 0;
        WHILE rr <= 2 & pc < 12  DO
            cc := 0;
            WHILE cc <= 8 & pc < 12  DO
                IF rr mod 2 = 0 & cc mod 2 = 0
                THEN 
                    row1(pc) := rr;
                    column1(pc) := cc;
                    pc := pc+1;
                END;
                cc := cc+1;
            INVARIANT
                !pci.(pci:(0..pc-1)=> row1(pci) <= rr & column1(pci)<= cc)
            VARIANT (cc-8)
            END;
            rr:= rr+1
        INVARIANT
            !pci.(pci:(0..pc-1)=> row1(pci) <= rr & column1(pci)<= cc)
        VARIANT (rr-2)
        END;
        
        pc := 0;
        rr := 8;
        cc := 0;
        WHILE rr >= 6 & pc < 12  DO
            cc := 0;
            WHILE cc <= 8 & pc < 12  DO
                IF rr mod 2 = 0 & cc mod 2 = 0
                THEN 
                    row2(pc) := rr;
                    column2(pc) := cc;
                    pc := pc+1;
                END;
                cc := cc+1;
            INVARIANT
                !pci.(pci:(0..pc-1) => row1(pci) >= rr & column1(pci)<= cc)
            VARIANT (cc-8)
            END;
            rr:= rr-1
        INVARIANT
            !pci.(pci:(0..pc-1) => row1(pci) >= rr & column1(pci)<= cc)
        VARIANT (8-rr)
        END
    END
    
    
    
    
    //    pieces_positions1 := {0 |-> (1,1), 1 |-> (1,3), 2 |-> (1,5), 3 |-> (1,7),
    //        4 |-> (2,2), 5 |-> (2,4), 6 |-> (2,6), 7 |-> (2,8),
    //        8 |-> (3,1), 9 |-> (3,3), 10 |-> (3,5), 11 |-> (3,7)};
    //    pieces_positions2  := {0 |-> (8,2), 1 |-> (8,4), 2 |-> (8,6), 3 |-> (8,8),
    //        4 |-> (7,1), 5 |-> (7,3), 6 |-> (7,5), 7 |-> (7,7),
    //        8 |-> (6,2), 9 |-> (6,4), 10 |-> (6,6), 11 |-> (6,8)};
    
    
LOCAL_OPERATIONS
    cp <-- get_current_player = cp := current_player;
    
    ca <-- get_current_array = ca := current_array;   
    
OPERATIONS    
    
    move(rr,cc) =
    BEGIN
        current_array := (0..3) * {0}; // TALVEZ WHILE
        IF current_player = P1 & current_piece <= 0 & current_piece >= 11
        THEN 
            row1(current_piece) := rr;
            column1(current_piece) := cc;//pieces_positions1 := pieces_positions1 <+ { current_piece |-> (rr,cc)} || current_player := P2 ||
            IF rr = 8
            THEN promote_to_checker(current_piece, current_player);
            END;
        ELSE
            IF current_player = P2 & current_piece <= 0 & current_piece >= 11
            THEN 
                row2(current_piece) := rr;
                column2(current_piece) := cc;
                IF rr = 1
                THEN promote_to_checker(current_piece, current_player); 
                END;
            END;
        END;
        current_piece := -1;
    END;
    
    
    ww <-- have_a_piece (rr, cc) =
    BEGIN
        IF rr <= 1 & rr >= 8 & cc <= 1 & cc >= 8// : (1..8) & cc : (1..8)
        THEN
           
  
    END;
    
    
    oo <-- move_options(pc) =
    
     
    END;
    
    
    eat(pc, tg) =
    PRE  pc:(0..11) & tg:(0..11) & ((pc : pieces1 & tg : pieces2) or (pc : pieces2 & tg : pieces1))
    THEN
        //PARA O P1
        IF current_player = P1 & pc : pieces1 & tg : pieces2
        THEN
            // se tg estiver a esquerda
            IF (FIRST(pieces_positions1(pc)) + 1, SECOND(pieces_positions1(pc)) - 1) = (FIRST(pieces_positions2(tg)), SECOND(pieces_positions2(tg)))
            THEN
                //se não houver peça a esqueda para cima de tg
                IF (FIRST(pieces_positions2(tg)) + 1, SECOND(pieces_positions2(tg)) - 1) /: (ran(pieces_positions2) \/ ran(pieces_positions1)) 
                THEN
                    //move
                    pieces_positions1 := pieces_positions1 <+ { pc |-> (FIRST(pieces_positions1(pc)) + 2 , SECOND(pieces_positions1(pc)) - 2)} || current_player := P2 ||
                    remove_piece(tg,P2)|| pieces_positions2 := {tg} <<| pieces_positions2
                END
            ELSE
                // se tg estiver a direita
                IF (FIRST(pieces_positions1(pc)) + 1, SECOND(pieces_positions1(pc)) + 1) = (FIRST(pieces_positions2(tg)), SECOND(pieces_positions2(tg)))
                THEN
                    //se não houver peça a direita para cima de tg
                    IF (FIRST(pieces_positions2(tg)) + 1, SECOND(pieces_positions2(tg)) + 1) /: (ran(pieces_positions2) \/ ran(pieces_positions1)) 
                    THEN
                        //move
                        pieces_positions1 := pieces_positions1 <+ { pc |-> (FIRST(pieces_positions1(pc)) + 2 , SECOND(pieces_positions1(pc)) + 2)} || current_player := P2 ||
                        remove_piece(tg,P2)|| pieces_positions2 := {tg} <<| pieces_positions2 //||
                    END
                END
            END
            //////////////////////////////////////////////////////////
        ELSE
            //PARA O P2
            IF current_player = P2 & pc : pieces2 & tg : pieces1
            THEN
                // se tg estiver a esquerda
                IF (FIRST(pieces_positions2(pc)) - 1, SECOND(pieces_positions2(pc)) - 1) = (FIRST(pieces_positions1(tg)), SECOND(pieces_positions1(tg)))
                THEN
                    //se não houver peça a esuqeda para baixo de tg
                    IF (FIRST(pieces_positions1(tg)) - 1, SECOND(pieces_positions1(tg)) - 1) /: (ran(pieces_positions2) \/ ran(pieces_positions1)) 
                    THEN
                        //move
                        pieces_positions2 := pieces_positions2 <+ { pc |-> (FIRST(pieces_positions2(pc)) - 2 , SECOND(pieces_positions2(pc)) - 2)} || current_player := P1 ||
                        remove_piece(tg,P1)|| pieces_positions1 := {tg} <<| pieces_positions1 
                    END
                ELSE
                    // se tg estiver a direita
                    IF (FIRST(pieces_positions2(pc)) - 1, SECOND(pieces_positions2(pc)) + 1) = (FIRST(pieces_positions1(tg)), SECOND(pieces_positions1(tg)))
                    THEN
                        //se não houver peça a esuqeda para cima de tg
                        IF (FIRST(pieces_positions1(tg)) - 1, SECOND(pieces_positions1(tg)) + 1) /: (ran(pieces_positions2) \/ ran(pieces_positions1)) 
                        THEN
                            //move
                            pieces_positions2 := pieces_positions2 <+ { pc |-> (FIRST(pieces_positions2(pc)) - 2 , SECOND(pieces_positions2(pc)) + 2)} || current_player := P1 ||
                            remove_piece(tg,P1)|| pieces_positions1 := {tg} <<| pieces_positions1
                        END
                    END   
                END
            END
        END
    END
    
END